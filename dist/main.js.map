{"version":3,"file":"main.js","sources":["../src/main.js"],"sourcesContent":["/* eslint-disable no-use-before-define */\nconst jwt = require('jsonwebtoken');\nconst request = require('request');\n\n/**\n * verifyJWT() determines the authentication approache with parameter authLevel\n *\n * @param {string} configJsonString\n * JSON string containing authLevel, openidPublicKey, openidEndpoint, enabled::\n * authLevel          1 => Authenticate JWT Access Token with public key;\n *                    2 => Authenticate by POST to OpenID Endpoint\n * publicKey          Public Key for validating OpenID JWT Access Token\n * endpoint           OpendID Endpoint for authentication\n *\n */\nfunction verifyJWT(configJsonString) {\n  const {\n    authLevel,\n    openidPublicKey,\n    openidEndpoint,\n    enabled,\n  } = JSON.parse(configJsonString);\n\n  if (!enabled) {\n    return (req, res, next) => next();\n  }\n\n  switch (authLevel) {\n    case 1:\n      return verifyWithOpenIDJwtToken(openidPublicKey);\n    case 2:\n      return verifyWithOpenIDEndpoint(openidEndpoint);\n    default:\n      return (req, res) => res.status(500).json({ error: 'Server Internal Error' });\n  }\n}\n\n/**\n * verifyWithOpenIDJwtToken() offers OFFLINE JWT Token verification by using the public key\n *\n * @param {string} publicKey        Public Key for OpenID JWT verification\n */\nfunction verifyWithOpenIDJwtToken(publicKey) {\n  return (req, res, next) => {\n    // Checking: if publicKey is valid input\n    if (publicKey === '' || publicKey === 'undefined' || publicKey === null) {\n      res.status(400).json({ error: 'Bad request' });\n    }\n    const openidPublicKey = `-----BEGIN PUBLIC KEY-----\\n${publicKey}\\n-----END PUBLIC KEY-----`;\n\n    if (req.headers.authorization) {\n      const accessToken = req.headers.authorization.split(' ')[1];\n      if (accessToken === '' || accessToken === 'undefined' || accessToken === null) {\n        res.status(400).json({ error: 'Bad Request' });\n      }\n\n      // Verify Access Token with jsonwebtoken plugin\n      jwt.verify(accessToken, openidPublicKey, (error, decodedResult) => {\n        if (error) {\n          res.status(401).json({ error: 'Unauthorized' });\n        }\n\n        if (typeof (decodedResult) === 'object' && decodedResult.preferred_username\n          && (decodedResult.exp * 1000 >= Date.now())) {\n          next();\n        } else {\n          res.status(401).json({ error: 'Unauthorized' });\n        }\n      });\n    } else {\n      res.status(400).json({ error: 'Bad Request' });\n    }\n  };\n}\n\n/**\n * verifyWithOpenIDEndpoint() offers ONLINE authentication by sending POST request\n * to OpenID Endpoint to perform authentication\n *\n * @param {string} endpoint         OpenID Endpoint for authentication use\n */\nfunction verifyWithOpenIDEndpoint(endpoint) {\n  return (req, res, next) => {\n    // Checking: if endpoint is valid input\n    if (endpoint === '' || endpoint === 'undefined' || endpoint === null) {\n      res.status(400).json({ error: 'Bad request' });\n    }\n\n    if (req.headers.authorization) {\n      const endpointRequestOption = {\n        method: 'post',\n        url: endpoint,\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          Authorization: req.headers.authorization,\n        },\n        strictSSL: false,\n        form: {},\n      };\n\n      request(endpointRequestOption, (error, requestResponse) => {\n        if (error) {\n          res.status(401).json({ error: 'Unauthorized' });\n        }\n\n        if (requestResponse.statusCode === 200) {\n          next();\n        } else {\n          res.status(401).json({ error: 'Unauthorized' });\n        }\n      });\n    } else {\n      res.status(400).json({ error: 'Bad Request' });\n    }\n  };\n}\n\n\nmodule.exports.verifyJWT = verifyJWT;\nmodule.exports.verifyWithOpenIDJwtToken = verifyWithOpenIDJwtToken;\nmodule.exports.verifyWithOpenIDEndpoint = verifyWithOpenIDEndpoint;\n"],"names":["jwt","require","request","verifyJWT","configJsonString","JSON","parse","authLevel","openidPublicKey","openidEndpoint","enabled","req","res","next","verifyWithOpenIDJwtToken","verifyWithOpenIDEndpoint","status","json","error","publicKey","accessToken","headers","authorization","split","verify","decodedResult","_typeof","preferred_username","exp","Date","now","endpoint","endpointRequestOption","method","url","Authorization","strictSSL","form","requestResponse","statusCode","module","exports"],"mappings":"8PACA,IAAMA,IAAMC,QAAQ,gBACdC,QAAUD,QAAQ,WAaxB,SAASE,UAAUC,SAMbC,KAAKC,MAAMF,GAJbG,IAAAA,UACAC,IAAAA,gBACAC,IAAAA,qBACAC,eAIO,SAACC,EAAKC,EAAKC,UAASA,YAGrBN,QACD,SACIO,yBAAyBN,QAC7B,SACIO,yBAAyBN,kBAEzB,SAACE,EAAKC,UAAQA,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,4BASzD,SAASJ,yBAAyBK,UACzB,SAACR,EAAKC,EAAKC,GAEE,KAAdM,GAAkC,cAAdA,GAA2C,OAAdA,GACnDP,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,oBAKxBE,EAHFZ,wCAAiDW,gCAEnDR,EAAIU,QAAQC,eAEM,MADdF,EAAcT,EAAIU,QAAQC,cAAcC,MAAM,KAAK,KACf,cAAhBH,GAA+C,OAAhBA,GACvDR,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,gBAIhClB,IAAIwB,OAAOJ,EAAaZ,EAAiB,SAACU,EAAOO,GAC3CP,GACFN,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,iBAGD,WAA3BQ,QAAQD,IAA+BA,EAAcE,oBAC/B,IAApBF,EAAcG,KAAcC,KAAKC,MACrCjB,IAEAD,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,oBAIlCN,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,iBAWpC,SAASH,yBAAyBgB,UACzB,SAACpB,EAAKC,EAAKC,OAORmB,EALS,KAAbD,GAAgC,cAAbA,GAAyC,OAAbA,GACjDnB,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,gBAG5BP,EAAIU,QAAQC,eACRU,EAAwB,CAC5BC,OAAQ,OACRC,IAAKH,EACLV,QAAS,gBACS,oCAChBc,cAAexB,EAAIU,QAAQC,eAE7Bc,WAAW,EACXC,KAAM,IAGRnC,QAAQ8B,EAAuB,SAACd,EAAOoB,GACjCpB,GACFN,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,iBAGG,MAA/BoB,EAAgBC,WAClB1B,IAEAD,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,oBAIlCN,EAAII,OAAO,KAAKC,KAAK,CAAEC,MAAO,iBAMpCsB,OAAOC,QAAQtC,UAAYA,UAC3BqC,OAAOC,QAAQ3B,yBAA2BA,yBAC1C0B,OAAOC,QAAQ1B,yBAA2BA"}